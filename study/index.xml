<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Studies on Ken Blog</title>
    <link>/study/</link>
    <description>Recent content in Studies on Ken Blog</description>
    <image>
      <url>/papermod-cover.png</url>
      <link>/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 17 Aug 2022 17:46:00 +0800</lastBuildDate><atom:link href="/study/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>powerdns-学习如何搭建个人专属DNS服务器</title>
      <link>/study/powerdns/</link>
      <pubDate>Wed, 17 Aug 2022 17:46:00 +0800</pubDate>
      
      <guid>/study/powerdns/</guid>
      <description>powerdns | powerdns_http_api | download link
1、 环境 environment 系统 centos 7.9
2、 安装 install powerdns yum install epel-release yum-plugin-priorities curl -o /etc/yum.repos.d/powerdns-auth-45.repo https://repo.powerdns.com/repo-files/centos-auth-45.repo
yum install pdns
3、 安装 install pdns-recursor yum -y install epel-release yum-plugin-priorities curl -o /etc/yum.repos.d/powerdns-rec-45.repo https://repo.powerdns.com/repo-files/centos-rec-45.repo yum -y install pdns-recursor
4、 配置 configure 修改mysql配置文件
[mysqld] /etc/my.cnf
innodb_file_per_table = 1 innodb_flush_log_at_trx_commit = 0 character-set-server=utf8 collation-server=utf8_general_ci create database poweradmin; grant all on poweradmin.* to puser1@localhost identified by &amp;#34;wisdom123@&amp;#34;; flush privileges; mysql -u root poweradmin &amp;lt; /usr/share/doc/pdns-backend-mysql-4.</description>
    </item>
    
    <item>
      <title>wechaty-描述各方法的类型</title>
      <link>/study/wechaty-002/</link>
      <pubDate>Mon, 15 Aug 2022 11:31:00 +0800</pubDate>
      
      <guid>/study/wechaty-002/</guid>
      <description>Message 简单来说就是消息,在微信中聊天的文字,转账,语音等等都是消息的一种,因此是最重要的一项 官网
# 消息类型 class MessageType(betterproto.Enum): MESSAGE_TYPE_UNSPECIFIED = 0 MESSAGE_TYPE_ATTACHMENT = 1 MESSAGE_TYPE_AUDIO = 2 MESSAGE_TYPE_CONTACT = 3 MESSAGE_TYPE_EMOTICON = 4 MESSAGE_TYPE_IMAGE = 5 图像 MESSAGE_TYPE_TEXT = 6 文字 MESSAGE_TYPE_VIDEO = 7 MESSAGE_TYPE_CHAT_HISTORY = 8 MESSAGE_TYPE_LOCATION = 9 MESSAGE_TYPE_MINI_PROGRAM = 10 MESSAGE_TYPE_TRANSFER = 11 MESSAGE_TYPE_RED_ENVELOPE = 12 MESSAGE_TYPE_RECALLED = 13 MESSAGE_TYPE_URL = 14 常用说明:
type 消息类型,具体类型参考上述 print(msg.type()) text 接受的文本信息 print(msg.text()) say 回复信息,不仅文本消息,图片等都可以发送 await msg.say(msg.text()) 发送图片
from wechaty import (FileBox) file_box = FileBox.</description>
    </item>
    
    <item>
      <title>wechaty-初识wechaty用途</title>
      <link>/study/wechaty-001/</link>
      <pubDate>Mon, 15 Aug 2022 11:30:00 +0800</pubDate>
      
      <guid>/study/wechaty-001/</guid>
      <description>wechaty能做到什么 能自定制微信机器人服务,为你订造专属智能客服 能利用微信强大的社交机制带来潜在利益 github | 官网教程
其他教程 wechaty.readthedocs.io
有关视频教程资源:
live-coding
AI情话
准备阶段，有条件的小伙伴可以自己搭建一个服务端，好处就在于免费，或者可以使用网上其他提供协议,可参考 Padlocal协议 和 Paimon协议, 本教程主要以自搭建为主</description>
    </item>
    
    <item>
      <title>从0到1 记录搭建Hugo个人博客-03 使用Algolia搜索</title>
      <link>/study/hugo-003/</link>
      <pubDate>Mon, 15 Aug 2022 11:24:00 +0800</pubDate>
      
      <guid>/study/hugo-003/</guid>
      <description>Hugo添加Algolia搜索支持 本文主要介绍如何在Hugo上增加Algolia的搜索支持,Alogolia官网
添加Algolia搜索支持主要以下步骤： ###1. 进入 Algolia 官网注册创建环境
个人使用选择免费版即可,可以满足日常需求了
地区若是国内则建议选择Hong Kong ,延迟较小效果比较好
最后提交即可
###2. 创建Application和Index 名称可自定义,我为了方便区别,创建都习惯用直接的域名作为名称 https://www.algolia.com/account/api-keys/all?applicationId=你的applicationId ###3. Hugo配置Algolia的环境
修改 config.toml 文件声明需要生成Algolia索引文件以及相关信息 [outputs]
home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;RSS&amp;rdquo;, &amp;ldquo;Algolia&amp;rdquo;]
&amp;hellip;中间省略
[outputFormats.Algolia]
baseName = &amp;ldquo;algolia&amp;rdquo;
isPlainText = true
mediaType = &amp;ldquo;application/json&amp;rdquo;
notAlternative = true
[params.algolia]
appId = &amp;ldquo;你的Application ID&amp;rdquo;
indexName = &amp;ldquo;你的索引名字&amp;rdquo;
searchOnlyKey = &amp;ldquo;你的Search-Only API Key&amp;rdquo;
注意outputs下面home的末尾有&amp;quot;Algolia&amp;quot;，漏了就不会生成了。 appId, indexName, searchOnlyKey 填写刚才记录的Algolia信息。
根目录下 layouts/_default (没有就新建) 文件夹中新建 list.algolia.json 文件，内容如下: {{/* 生成Algolia搜索索引文件 /}}
{{- $.Scratch.Add &amp;ldquo;index&amp;rdquo; slice -}}</description>
    </item>
    
    <item>
      <title>php-laravel升级注意事项</title>
      <link>/study/php-laravel-002/</link>
      <pubDate>Mon, 15 Aug 2022 11:18:00 +0800</pubDate>
      
      <guid>/study/php-laravel-002/</guid>
      <description>官网 现在laravel的最新版已经升级到了9.0,目前公司还在用5.x版本,因此对于升级的注意事项做个记录,当做预防以后的踩坑
注意事项
同一个设置成支持php7.0,php8,新的9.0仅支持php8以上,为了能平滑迁移项目,需要服务器可支持2个版本 购物车插件gloudemans/shoppingcart 不可使用 , 测试 bumbummen99/shoppingcart 是否可替代 接收参数函数 Input::get() 废弃,用request()-&amp;gt;get() 替代 $input{$i+1} 花括号不可用 $input[$i+1] Route::controller 隐式控制路由废弃, 使用lesichkovm/laravel-advanced-route 插件 AdvancedRoute::controller 替代 队列在redis上保存的值有较大变动, laravel/vendor/laravel/framework/src/Illuminate/Queue/Queue.php createPayload函数 增加部分变量 laravel/vendor/laravel/framework/src/Illuminate/Queue/RedisQueue.php createPayload函数 attempts设置默认为0 原生类的构造函数改成__construct 对于整形和字符串判断更严格了,如mktime 参数必须是int; abs(&amp;quot;&amp;quot;) 会报错 有用到的废弃函数 create_function 需要更换 ORM查询返回的数据永远是obj类型, conf/database.inc.php 设置的$ORM-&amp;gt;setFetchMode(PDO::FETCH_ASSOC); 无效,源自 https://laravel.com/docs/5.4/upgrade 以上的记录是我实际的项目产生的问题,因此不一定适合大部分人
正则表达式替换php7的语法警告
(\$[a-zA-Z\_]+)\[([a-zA-Z]+[a-zA-Z\_\d]*)\] $1[&amp;#39;$2&amp;#39;] </description>
    </item>
    
    <item>
      <title>php-总结laravel使用技巧-001</title>
      <link>/study/php-laravel-001/</link>
      <pubDate>Mon, 15 Aug 2022 11:05:00 +0800</pubDate>
      
      <guid>/study/php-laravel-001/</guid>
      <description>是否有人对于每次写一个laravel的控制器都要在路由上写一堆的声明路由感到麻烦,后期维护又不好处理,这里总结下如何让自己写出的接口更加规范格式化,本人在laravel项目中使用了dingo/api
.env上配置dingo的配置信息 #Dingo API API_PREFIX=api API_VERSION=v1 API_DEBUG=true 在route.php的路由方法中添加这几行代码 $api = app(&amp;#39;Dingo\Api\Routing\Router&amp;#39;); $api-&amp;gt;version(&amp;#39;v1&amp;#39;, function ($api) { $api-&amp;gt;any(&amp;#39;{slug}&amp;#39;, &amp;#39;\App\Http\ApiRouter@route&amp;#39;)-&amp;gt;where(&amp;#39;slug&amp;#39;, &amp;#39;(.*)?&amp;#39;); }); 封装统一入口ApiRouter.php use App; use Dingo\Api\Routing\Helpers; use Illuminate\Routing\Controller; use Illuminate\Support\Str; use core\util\router\RouterHelper; class ApiRouter extends Controller { use Helpers; private $ns; const API_NS = &amp;#39;core\bapi&amp;#39;; function __construct($ns) { header(&amp;#39;Access-Control-Allow-Origin: *&amp;#39;); header(&amp;#39;Access-Control-Allow-Methods:*&amp;#39;); header(&amp;#39;Access-Control-Allow-Headers:*&amp;#39;); $this-&amp;gt;ns = $ns; } /** * @var string Allows early access to page action. */ public static $action; /** * @var array Allows early access to page parameters.</description>
    </item>
    
    <item>
      <title>Php-自定义封装加密方法</title>
      <link>/study/php-encrypter/</link>
      <pubDate>Mon, 15 Aug 2022 10:34:00 +0800</pubDate>
      
      <guid>/study/php-encrypter/</guid>
      <description>/** * 自定义的一个加解密插件 * User: staff * Date: 2019/3/27 * Time: 16:13 */ class Encrypter { private static $key = &amp;#34;ZmUbqPipJ0Pr7tGmkHDBazjpbKjFZc7S&amp;#34;; private static $cipher = &amp;#34;AES-256-CBC&amp;#34;; public static function encrypt($str) { $ivlen = openssl_cipher_iv_length(self::$cipher); $iv = openssl_random_pseudo_bytes($ivlen); $value = openssl_encrypt($str, self::$cipher, self::$key, 0, $iv); $iv = base64_encode($iv); $param = [ &amp;#39;iv&amp;#39; =&amp;gt; $iv, &amp;#39;value&amp;#39; =&amp;gt; $value ]; return base64_encode(json_encode($param)); } public static function decrypt($str) { $payload = self::getJsonPayload($str); $iv = base64_decode($payload[&amp;#39;iv&amp;#39;]); $decrypted = openssl_decrypt($payload[&amp;#39;value&amp;#39;], self::$cipher, self::$key, 0, $iv); return $decrypted; } /** * @param $payload * @return array */ static function getJsonPayload($payload) { $payload = json_decode(base64_decode($payload), true); return $payload; } } </description>
    </item>
    
    <item>
      <title>Php-根据经纬度计算直线距离</title>
      <link>/study/php-distance/</link>
      <pubDate>Fri, 12 Aug 2022 16:53:00 +0800</pubDate>
      
      <guid>/study/php-distance/</guid>
      <description> static public $DEF_PI = 3.14159265359; // PI static public $DEF_2PI= 6.28318530712; // 2*PI static public $DEF_PI180= 0.01745329252; // PI/180.0 static public $DEF_R =6370693.5; // radius of earth /** * 适用于近距离测直线距离 */ public static function GetShortDistance($lon1, $lat1, $lon2, $lat2) { // 角度转换为弧度 $ew1 = $lon1 * self::$DEF_PI180; $ns1 = $lat1 * self::$DEF_PI180; $ew2 = $lon2 * self::$DEF_PI180; $ns2 = $lat2 * self::$DEF_PI180; // 经度差 $dew = $ew1 - $ew2; // 若跨东经和西经180 度，进行调整 if ($dew &amp;gt; self::$DEF_PI) $dew = self::$DEF_2PI - $dew; else if ($dew &amp;lt; -self::$DEF_PI) $dew = self::$DEF_2PI + $dew; $dx = self::$DEF_R * cos($ns1) * $dew; // 东西方向长度(在纬度圈上的投影长度) $dy = self::$DEF_R * ($ns1 - $ns2); // 南北方向长度(在经度圈上的投影长度) // 勾股定理求斜边长 $distance = sqrt($dx * $dx + $dy * $dy); return $distance; } </description>
    </item>
    
    <item>
      <title>Php-生成ssl证书所需的csr信息</title>
      <link>/study/php-ssl/</link>
      <pubDate>Fri, 12 Aug 2022 16:45:00 +0800</pubDate>
      
      <guid>/study/php-ssl/</guid>
      <description>/** * 生成CSR和KEY */ public function CreateCsr() { $all = request()-&amp;gt;all(); $dn = [ &amp;#34;countryName&amp;#34; =&amp;gt; trim(strtoupper($all[&amp;#39;countryName&amp;#39;])), //所在国家 &amp;#34;stateOrProvinceName&amp;#34; =&amp;gt; trim($all[&amp;#39;stateOrProvinceName&amp;#39;]), //所在省份 &amp;#34;localityName&amp;#34; =&amp;gt; trim($all[&amp;#39;localityName&amp;#39;]), //所在城市 &amp;#34;organizationName&amp;#34; =&amp;gt; trim($all[&amp;#39;organizationName&amp;#39;]), //注册人姓名 &amp;#34;organizationalUnitName&amp;#34; =&amp;gt; trim($all[&amp;#39;organizationalUnitName&amp;#39;]), //组织名称 &amp;#34;commonName&amp;#34; =&amp;gt; trim($all[&amp;#39;commonName&amp;#39;]), //公共名称 ]; if (isset($all[&amp;#39;emailAddress&amp;#39;]) &amp;amp;&amp;amp; $all[&amp;#39;emailAddress&amp;#39;]) { $dn[&amp;#39;emailAddress&amp;#39;] = $all[&amp;#39;emailAddress&amp;#39;]; } $config = [ &amp;#34;private_key_bits&amp;#34; =&amp;gt; isset($all[&amp;#39;keysize&amp;#39;]) &amp;amp;&amp;amp; $all[&amp;#39;keysize&amp;#39;] ? $all[&amp;#39;keysize&amp;#39;] : 2048, //字节数 512 1024 2048 4096 等 &amp;#34;private_key_type&amp;#34; =&amp;gt; OPENSSL_KEYTYPE_RSA, //加密类型 &amp;#39;digest_alg&amp;#39; =&amp;gt; &amp;#39;sha256&amp;#39;, ]; $privkey = openssl_pkey_new($config); if ($privkey === false) { $config[&amp;#39;config&amp;#39;] = &amp;#34;D:/phpstudy_pro/Extensions/Apache2.</description>
    </item>
    
    <item>
      <title>Python-初学tensorflow第二天-学习例子</title>
      <link>/study/python-tensorflow-002/</link>
      <pubDate>Fri, 12 Aug 2022 15:18:00 +0800</pubDate>
      
      <guid>/study/python-tensorflow-002/</guid>
      <description>学习来源Bilibili 根据例子编写出线性回归方程
import tensorflow as tf import pandas as pd data=pd.read_csv(&amp;#39;./demo1.csv&amp;#39;) x=data.Education y=data.Income model=tf.keras.Sequential(()) model.add(tf.keras.layers.Dense(1,input_shape=(1,))) model.compile(optimizer=&amp;#39;adam&amp;#39;,loss=&amp;#39;mse&amp;#39;) history=model.fit(x,y,epochs=10000) res=model.predict(pd.Series([20])) print(res) ,Education,Income
1,10.000000 ,26.658839
2,10.401338 ,27.306435
3,10.842809 ,22.132410
4,11.244147 ,21.169841
5,11.645449 ,15.192634
6,12.086957 ,26.398951
7,12.048829 ,17.435307
8,12.889632 ,25.507885
9,13.290970 ,36.884595
10,13.732441 ,39.666109
11,14.133779 ,34.396281
12,14.635117 ,41.497994
13,14.978589 ,44.981575
14,15.377926 ,47.039595
15,15.779264 ,48.252578
16,16.220736 ,57.034251
17,16.622074 ,51.490919
18,17.023411 ,51.336621
19,17.464883 ,57.681998
20,17.866221 ,68.553714
21,18.267559 ,64.310925
22,18.709030 ,68.959009
23,19.110368 ,74.614639
24,19.511706 ,71.867195
25,19.913043 ,76.098135</description>
    </item>
    
    <item>
      <title>Python-初学tensorflow第一天-搭建环境</title>
      <link>/study/python-tensorflow-001/</link>
      <pubDate>Fri, 12 Aug 2022 15:12:00 +0800</pubDate>
      
      <guid>/study/python-tensorflow-001/</guid>
      <description>初学第一天主要学习如果搭建环境和快捷安装TensorFlow的扩展
打开miniconda官网 选择合适自己的系统来安装python环境 安装TensorFlow扩展 : pip install tensorflow==2.8.0 可能pip版本不够导致安装失败 easy_install -U pip 安装其他所需的包: pip install pandas matplotlib nodebook pandas 数据分析库 matplotlib python绘图库 nodebook 基于web的开发环境 安装cuda 安装pytorch Q: 运行失败时返回 Could not load dynamic library &amp;lsquo;cudart64_110.dll&amp;rsquo;; dlerror: cudart64_110.dll not found A: 在截图中找到相应的版本后,打开 nvidia
Q: 安装cuda失败时返回 you already have a newer version of the nvdia frameview sdk installed
A: 找到C:\Program Files\NVIDIA Corporation\FrameViewSDK文件夹进行卸载
Q: 安装cuda一直安装不成功,nsight visual studio edition提示安装失败 A: 尝试卸载电脑的Visual Studio Community
Q: Downgrade the protobuf package to 3.</description>
    </item>
    
    <item>
      <title>初始Python-自动化操作</title>
      <link>/study/python-selenium/</link>
      <pubDate>Fri, 12 Aug 2022 15:10:00 +0800</pubDate>
      
      <guid>/study/python-selenium/</guid>
      <description>Selenium是一个用于测试网站的自动化测试工具，支持各种浏览器包括Chrome、Firefox、Safari等主流界面浏览器，同时也支持phantomJS无界面浏览器。
以下是我在实际使用中对于selenium的一些心得和用法
implicitly_wait
等待浏览器的相应时间,与sleep的区别在于implicitly_wait是设置的值或页面超时优先,而sleep则是固定睡眠时间,我在用的时候则是2个都同时使用.确保页面能顺利加载到需要的数据
xpath 如果需要用selenium进行简单的爬虫和模拟浏览,那么xpath的语法是必须要了解明白的,html语言中比起正则,xpath的代码更加清晰和直观
click 对于按钮的点击事件,推荐用
driver.execute_script(&amp;#34;arguments[0].click();&amp;#34;, nextButton) 据说.click()会导致报错,虽然我还没遇到过</description>
    </item>
    
    <item>
      <title>初始Python-文件操作</title>
      <link>/study/python-001/</link>
      <pubDate>Fri, 12 Aug 2022 15:05:00 +0800</pubDate>
      
      <guid>/study/python-001/</guid>
      <description>列出指定目录下的全部文件
import os file_array=[] dir_array=[ os.getcwd() + &amp;#34;/directory1/&amp;#34;, os.getcwd() + &amp;#34;/directory2/&amp;#34;, ] for dir in dir_array: for root, dirs, files in os.walk(dir): for filename in files: file_array.append(dir+filename) Excel操作读写
wb = xlrd.open_workbook(filepath) sh = wb.sheet_by_name(&amp;#39;数据明细&amp;#39;) # print(sh.nrows) # 有效数据行数 # print(sh.ncols) # 有效数据列数 for index in range(len(sh.row_values(0))): title = sh.row_values(0)[index] </description>
    </item>
    
    <item>
      <title>Apache</title>
      <link>/study/apache/</link>
      <pubDate>Fri, 12 Aug 2022 13:47:00 +0800</pubDate>
      
      <guid>/study/apache/</guid>
      <description> apacha限制某个目录的php执行 &amp;lt;Directory /public/protected/controllers&amp;gt; php_flag engine off &amp;lt;/Directory&amp;gt; 需要注意网站已经定义的路径，如果涉及到软路径，一律以已经定义的路径为准。
apacha动态IP黑名单 能简单的设置apache黑名单,配合自己的项目能有效禁止非法IP高频的访问 http.conf &amp;lt;VirtualHost *:443&amp;gt; RewriteMap ipmap txt:ipmap.txt 项目.htaccess
RewriteCond ${ipmap:%{REMOTE_ADDR}} ^b$ [NC] RewriteRule .* - [F,L] ipmap.txt 内容
127.0.0.1 b 8.8.8.8 b </description>
    </item>
    
    <item>
      <title>Centos-工作中随手的记录</title>
      <link>/study/centos/</link>
      <pubDate>Fri, 12 Aug 2022 13:46:00 +0800</pubDate>
      
      <guid>/study/centos/</guid>
      <description> CentOS7利用yum安装node.js curl -sL https://rpm.nodesource.com/setup_16.x | bash - yum install -y nodejs node -v cnpm安装 npm install -g cnpm --registry=https://registry.npmmirror.com CentOS7 安装pip3 yum install epel-release yum install https://centos7.iuscommunity.org/ius-release.rpm 多个文件内容搜索特定关键词 grep -ln &amp;ldquo;keyword&amp;rdquo; 05-01-00hour.log &amp;hellip;(可以携带多个文件名)
打印存在关键词的文件名
05-19-19hour.log
05-20-00hour.log </description>
    </item>
    
    <item>
      <title>gitfun</title>
      <link>/study/gitfun/</link>
      <pubDate>Fri, 12 Aug 2022 12:29:00 +0800</pubDate>
      
      <guid>/study/gitfun/</guid>
      <description>用于git角色登录服务器,触发版本pull和同步 /home/git/gitfun.inc.sh
#!/bin/sh /bin/stty intr &amp;#39;&amp;#39; function git_checkout() { if [ -d $checkout_path/.git ];then cd $checkout_path git pull $git_url #git pull $git_url $branch #checkout a branch chmod 700 $checkout_path/.git echo $git_url update finish! else mkdir -p $checkout_path if [ ! -d $checkout_path ];then exit fi cd $checkout_path/../ git clone $git_url #git checkout $branch #switch to branch chmod 700 $checkout_path/.git if [ -d $checkout_path/.git ];then echo $git_url has checkout successfully! fi fi } function git_checkout_branch() { if [ -d $checkout_path/.</description>
    </item>
    
    <item>
      <title>Mysql数据库-使用记录</title>
      <link>/study/mysql-note/</link>
      <pubDate>Fri, 12 Aug 2022 12:13:00 +0800</pubDate>
      
      <guid>/study/mysql-note/</guid>
      <description>How to show binlog mysqlbinlog --no-defaults --start-datetime=&amp;#34;2021-09-30 00:00:00&amp;#34; --stop-datetime=&amp;#34;2021-09-30 23:00:00&amp;#34; -d database --base64-output=DECODE-ROWS -v /binlog/master-bin.001255 --result-file=/root/binlog/mysqllog001255.sql How to get distance ( lat and lng) lat = X lng = X select * , ROUND(6378.138 * 2 * ASIN(SQRT(POW(SIN(({$lat} * PI() / 180 - lat * PI() / 180) / 2),2) + COS({$lat} * PI() / 180) * COS(lat * PI() / 180) * POW(SIN(({$lng} * PI() / 180 - lng * PI() / 180) / 2),2))), 5)*1000 AS distance from table order by distance asc </description>
    </item>
    
    <item>
      <title>Mysql数据库-日期函数</title>
      <link>/study/mysql-001/</link>
      <pubDate>Fri, 12 Aug 2022 11:18:00 +0800</pubDate>
      
      <guid>/study/mysql-001/</guid>
      <description>当前日期
select curdate(); 当月最后一天
select last_day(curdate()); 下个月的上一天,例如今天2022-06-01 ,结果为2022-06-30
select DATE_SUB(DATE_ADD(CURDATE(),INTERVAL 1 MONTH),INTERVAL 1 DAY) 下个月的最后一天
select LAST_DAY(DATE_ADD(CURDATE(),INTERVAL 1 MONTH)); </description>
    </item>
    
    <item>
      <title>Mysql数据库-常见问题</title>
      <link>/study/mysql-question/</link>
      <pubDate>Fri, 12 Aug 2022 11:10:00 +0800</pubDate>
      
      <guid>/study/mysql-question/</guid>
      <description>能说下myisam 和 innodb的区别吗
myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。
innodb是基于聚簇索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。
说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么？
create table user( id int(11) not null, age int(11) not null, primary key(id), key(age) ); B+树是左小右大的顺序存储结构，节点只包含id索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。
事务的基本特性
原子性指的是一个事务中的操作要么全部成功，要么全部失败。
一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。
隔离性指的是一个事务的修改在最终提交前，对其他事务是不可见的。
持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中。
主从同步
首先先了解mysql主从同步的原理 master提交完事务后，写入binlog
slave连接到master，获取binlog
master创建dump线程，推送binglog到slave
slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中
slave再开启一个sql线程读取relay log事件并在slave执行，完成同步
slave记录自己的binglog</description>
    </item>
    
    <item>
      <title>Mongodb数据库-增删查改</title>
      <link>/study/mongodb-003/</link>
      <pubDate>Fri, 12 Aug 2022 11:09:00 +0800</pubDate>
      
      <guid>/study/mongodb-003/</guid>
      <description>find MongoDB中查询数据的基本指令,类似mysql中的select
example:
db.movies.find({&amp;#34;year&amp;#34;:1975}) db.movies.find({&amp;#34;year&amp;#34;:1975,&amp;#34;title&amp;#34;:&amp;#34;Kill&amp;#34;}) db.movies.find({$and:[{&amp;#34;title&amp;#34;:&amp;#34;Kill&amp;#34;},{&amp;#34;year&amp;#34;:1989}]}) db.movies.find({$or:[{&amp;#34;title&amp;#34;:&amp;#34;Kill&amp;#34;},{&amp;#34;year&amp;#34;:1989}]}) 子文档查询,如文档内容
{&amp;#34;name&amp;#34;:&amp;#34;apple&amp;#34;,&amp;#34;from&amp;#34;:{country:&amp;#34;China&amp;#34;,province:&amp;#34;Guangdong&amp;#34;}} db.fruit.find({&amp;#34;from.country&amp;#34;:&amp;#34;China&amp;#34;}) 条件语法
&amp;lt;&amp;gt; $ne &amp;gt; $gt &amp;gt;= $gte &amp;lt; $gt &amp;lt;= $lte is null {$exists:false} in {$in:[]} not in {$nin:[]} or $or and $and ##remove 删除文档
update updateOne 表示无论条件匹配多少条,只更新第一条
updateMany 匹配多少就更新多少
$push 增加一个对象到数组底部
$pushAll 增加多个对象到数组底部
$pop 从数组底部删除一个对象
$pull 如果匹配指定的值,从数组中删除对应的对象 $pullAll 如果匹配任意的值,从数据中删除对应的对象
$addToSet 如果不存在则增加一个值到数组
db.fruit.updateOne({name:&amp;#34;apple&amp;#34;},{$set:{from:&amp;#34;China&amp;#34;}}) drop 删除集合 </description>
    </item>
    
    <item>
      <title>Mongodb数据库-复制集</title>
      <link>/study/mongodb-002/</link>
      <pubDate>Fri, 12 Aug 2022 11:08:00 +0800</pubDate>
      
      <guid>/study/mongodb-002/</guid>
      <description>本地测试结果如下
|- D:\mongodata\db1
|&amp;mdash;&amp;mdash; mongo.conf
|- D:\mongodata\db2
|&amp;mdash;&amp;mdash; mongo.conf
mongo.conf
storage: dbPath: D:\mongodata\db1 journal: enabled: true systemLog: destination: file logAppend: true path: D:\mongodata\db1\mongod.log net: port: 28017 bindIp: 127.0.0.1 replication: replSetName: rs0 </description>
    </item>
    
    <item>
      <title>Mongodb数据库-初识</title>
      <link>/study/mongodb-001/</link>
      <pubDate>Fri, 12 Aug 2022 10:37:00 +0800</pubDate>
      
      <guid>/study/mongodb-001/</guid>
      <description>了解mongodb的基本情况
数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假） Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档 Null 用于创建空值 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息 Object ID 对象 ID。用于创建文档的 ID。　(每个文档都有) Binary Data 二进制数据。用于存储二进制数据 Code 代码类型。用于在文档中存储 JavaScript 代码 Regular expression 正则表达式 </description>
    </item>
    
    <item>
      <title>从0到1 记录搭建Hugo个人博客-02 选用模板</title>
      <link>/study/hugo-002/</link>
      <pubDate>Fri, 12 Aug 2022 10:17:00 +0800</pubDate>
      
      <guid>/study/hugo-002/</guid>
      <description>上文讲述了Hugo的如何搭建,这次讲述作者个人博客用的Hugo选用的模板hugo-PaperMod ，对于像我这种鉴赏能力为0的程序员，这么简单明了的风格瞬间让我沉迷了，因此也简单分享下搭建主题的过程
git pull https://github.com/adityatelange/hugo-PaperMod.git git switch exampleSite 此时目录结构包含有 content
assets
config.yml
复制到你的相应hugo项目下
config.yml的代码调整为:
profileMode: enabled: true 运行hugo后首页展示就和我当前的首页类似,简洁明了,恭喜你主题的搭建就完成了</description>
    </item>
    
    <item>
      <title>从0到1 记录搭建Hugo个人博客-01 搭建环境</title>
      <link>/study/hugo-001/</link>
      <pubDate>Thu, 11 Aug 2022 18:09:00 +0800</pubDate>
      
      <guid>/study/hugo-001/</guid>
      <description>使用HUGO搭建一个自己的博客Blog 对于常在敲代码的程序员来说,有个博客能记录和分享是一个相当有意义的事情， Hugo 是一个高效的网站搭建框架,能用简单的markdown语法编辑生成出富有个性的网页,即使是刚学的小白也能很简单的入门使用
说明：Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，同时也对图片、图表、数学公式提供了支持，可以用来书写电子书、软件文档等，同时也可以非常方便的转换为HTML页面或者是PDF文档。
step 1:安装环境
首先选择适合自己操作系统的环境https://github.com/gohugoio/hugo/releases/tag/v0.101.0 ,如我在window上使用就下载了 hugo_extended_0.101.0_Windows-64bit.zip step 2:创建一个新站点
hugo new site quickstart -f yml step 3:添加主题
根据自己的兴趣或者网站的用途,可以选择合适的博客主题,避免了例如我这种设计能力不足的程序员,只需简单的二次修饰即可上线
https://themes.gohugo.io/ cd quickstart git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke step 4:添加内容
辅助命令 hugo new posts/my-first-post.md 当然也可以自己手工创建在content目录下,如该页面就是在person/_index.md,文件格式如下:
--- title: &amp;#34;个人介绍&amp;#34; date: 2022-06-19T08:47:11+08:00 --- step 4:开始启动 如果在本地测试环境下想随时编辑查看,可使用 hugo server 此时打开http://localhost:1313就可以看到效果了 而需要上线编译的时候则可以简单的
hugo step 5:完成
最后把编译后的文件部署到你的服务器或者其他地方,搭配域名等就大功告成了 </description>
    </item>
    
  </channel>
</rss>
